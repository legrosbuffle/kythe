// Code generated by protoc-gen-gogo.
// source: kythe/proto/storage.proto
// DO NOT EDIT!

/*
	Package storage_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/storage.proto

	It has these top-level messages:
		VName
		VNameMask
		Entry
		Entries
		ReadRequest
		WriteRequest
		WriteReply
		ScanRequest
		CountRequest
		CountReply
		ShardRequest
*/
package storage_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// VName is a proto representation of a vector name.
//
// Rules:
//  - All fields must be optional, and must have default values.
//  - No field may ever be removed.  If a field is deprecated, it may be
//    renamed or marked with a comment, but must not be deleted.
//  - New fields are always added to the end of the message.
//  - All fields must be strings, not messages.
//
// One of the key principles is that we want as few fields as possible in a
// vname.  We're not trying to exhaust the possible dimensions along which a
// name could vary, but to find a minimal basis. Be conservative.
type VName struct {
	// A language-specific signature assigned by the analyzer.
	// e.g., "com.google.common.collect.Lists.newLinkedList<#1>()"
	Signature string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The corpus this name belongs to.
	// e.g., "kythe", "chromium", "github.com/creachadair/imath", "aosp"
	// The corpus label "kythe" is reserved for internal use.
	Corpus string `protobuf:"bytes,2,opt,name=corpus,proto3" json:"corpus,omitempty"`
	// A corpus-specific root label, designating a subordinate collection within
	// the corpus.  If a corpus stores files in unrelated directory structures,
	// for example, the root can be used to distinguish them.  Or, of a corpus
	// incorporates subprojects, the root can be a project ID that it governs.
	// This may also be used to distinguish virtual subgroups of a corpus such as
	// generated files.
	Root string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// A path-structured label describing the location of this object relative to
	// the corpus and the root.  For code, this will generally be the relative
	// path to the file containing the code, e.g., "storage/service.go" in kythe.
	//
	// However, this need not be a true file path; virtual objects like figments
	// can assign an ad-hoc abstract ID, or omit it entirely.
	//
	// Examples:
	//   "devools/kythe/platform/go/datastore.go" (a file)
	//   "type/cpp/void.cc" (a type figment)
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// The language this name belongs to.
	// e.g., "c++", "python", "elisp", "haskell", "java"
	//
	// The schema will define specific labels for each supported language, so we
	// don't wind up with a confusion of names like "cxx", "cpp", "C++", etc.
	// Prototype: Official language name converted to lowercase.  If a version
	// number is necessary, include it, e.g., "python3".
	Language string `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *VName) Reset()                    { *m = VName{} }
func (m *VName) String() string            { return proto.CompactTextString(m) }
func (*VName) ProtoMessage()               {}
func (*VName) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{0} }

func (m *VName) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *VName) GetCorpus() string {
	if m != nil {
		return m.Corpus
	}
	return ""
}

func (m *VName) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *VName) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *VName) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

type VNameMask struct {
	Signature bool `protobuf:"varint,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Corpus    bool `protobuf:"varint,2,opt,name=corpus,proto3" json:"corpus,omitempty"`
	Root      bool `protobuf:"varint,3,opt,name=root,proto3" json:"root,omitempty"`
	Path      bool `protobuf:"varint,4,opt,name=path,proto3" json:"path,omitempty"`
	Language  bool `protobuf:"varint,5,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *VNameMask) Reset()                    { *m = VNameMask{} }
func (m *VNameMask) String() string            { return proto.CompactTextString(m) }
func (*VNameMask) ProtoMessage()               {}
func (*VNameMask) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{1} }

func (m *VNameMask) GetSignature() bool {
	if m != nil {
		return m.Signature
	}
	return false
}

func (m *VNameMask) GetCorpus() bool {
	if m != nil {
		return m.Corpus
	}
	return false
}

func (m *VNameMask) GetRoot() bool {
	if m != nil {
		return m.Root
	}
	return false
}

func (m *VNameMask) GetPath() bool {
	if m != nil {
		return m.Path
	}
	return false
}

func (m *VNameMask) GetLanguage() bool {
	if m != nil {
		return m.Language
	}
	return false
}

// An Entry associates a fact with a graph object (node or edge).  This is the
// the primary unit of storage.
type Entry struct {
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// The following two fields must either be both empty, or both nonempty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,json=edgeKind,proto3" json:"edge_kind,omitempty"`
	Target   *VName `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	// The grammar for fact_name:
	//  name   = "/" | 1*path
	//  path   = "/" word
	//  word   = 1*{LETTER|DIGIT|PUNCT}
	//  LETTER = [A-Za-z]
	//  DIGIT  = [0-9]
	//  PUNCT  = [-.@#$%&_+:()]
	FactName  string `protobuf:"bytes,4,opt,name=fact_name,json=factName,proto3" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,5,opt,name=fact_value,json=factValue,proto3" json:"fact_value,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{2} }

func (m *Entry) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Entry) GetEdgeKind() string {
	if m != nil {
		return m.EdgeKind
	}
	return ""
}

func (m *Entry) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Entry) GetFactName() string {
	if m != nil {
		return m.FactName
	}
	return ""
}

func (m *Entry) GetFactValue() []byte {
	if m != nil {
		return m.FactValue
	}
	return nil
}

// A collection of Entry instances.
type Entries struct {
	Entries []*Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *Entries) Reset()                    { *m = Entries{} }
func (m *Entries) String() string            { return proto.CompactTextString(m) }
func (*Entries) ProtoMessage()               {}
func (*Entries) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{3} }

func (m *Entries) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Request for a stream of Entry objects from a GraphStore.  Read operations
// should be implemented with time complexity proportional to the size of the
// return set.
type ReadRequest struct {
	// Return entries having this source VName, which may not be empty.
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Return entries having this edge kind; if empty, only entries with an empty
	// edge kind are returned; if "*", entries of any edge kind are returned.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,json=edgeKind,proto3" json:"edge_kind,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{4} }

func (m *ReadRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *ReadRequest) GetEdgeKind() string {
	if m != nil {
		return m.EdgeKind
	}
	return ""
}

// Request to write Entry objects to a GraphStore
type WriteRequest struct {
	Source *VName                 `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Update []*WriteRequest_Update `protobuf:"bytes,2,rep,name=update" json:"update,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{5} }

func (m *WriteRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *WriteRequest) GetUpdate() []*WriteRequest_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

type WriteRequest_Update struct {
	EdgeKind  string `protobuf:"bytes,1,opt,name=edge_kind,json=edgeKind,proto3" json:"edge_kind,omitempty"`
	Target    *VName `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	FactName  string `protobuf:"bytes,3,opt,name=fact_name,json=factName,proto3" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,4,opt,name=fact_value,json=factValue,proto3" json:"fact_value,omitempty"`
}

func (m *WriteRequest_Update) Reset()                    { *m = WriteRequest_Update{} }
func (m *WriteRequest_Update) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest_Update) ProtoMessage()               {}
func (*WriteRequest_Update) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{5, 0} }

func (m *WriteRequest_Update) GetEdgeKind() string {
	if m != nil {
		return m.EdgeKind
	}
	return ""
}

func (m *WriteRequest_Update) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *WriteRequest_Update) GetFactName() string {
	if m != nil {
		return m.FactName
	}
	return ""
}

func (m *WriteRequest_Update) GetFactValue() []byte {
	if m != nil {
		return m.FactValue
	}
	return nil
}

// Response to a WriteRequest
type WriteReply struct {
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (m *WriteReply) String() string            { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{6} }

// Request for a stream of Entry objects resulting from a full scan of a
// GraphStore.
type ScanRequest struct {
	// Return entries having this target VName; if empty, any target field is
	// matched, including empty.
	Target *VName `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Return entries having this kind; if empty, any kind is matched, including
	// empty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,json=edgeKind,proto3" json:"edge_kind,omitempty"`
	// Return entries having fact labels with this prefix; if empty, any fact
	// label is matched,
	FactPrefix string `protobuf:"bytes,3,opt,name=fact_prefix,json=factPrefix,proto3" json:"fact_prefix,omitempty"`
}

func (m *ScanRequest) Reset()                    { *m = ScanRequest{} }
func (m *ScanRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()               {}
func (*ScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{7} }

func (m *ScanRequest) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ScanRequest) GetEdgeKind() string {
	if m != nil {
		return m.EdgeKind
	}
	return ""
}

func (m *ScanRequest) GetFactPrefix() string {
	if m != nil {
		return m.FactPrefix
	}
	return ""
}

// Request for the size of the shard at the given index.
type CountRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards,proto3" json:"shards,omitempty"`
}

func (m *CountRequest) Reset()                    { *m = CountRequest{} }
func (m *CountRequest) String() string            { return proto.CompactTextString(m) }
func (*CountRequest) ProtoMessage()               {}
func (*CountRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{8} }

func (m *CountRequest) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CountRequest) GetShards() int64 {
	if m != nil {
		return m.Shards
	}
	return 0
}

// Response for a CountRequest
type CountReply struct {
	// Total number of entries in the specified shard.
	Entries int64 `protobuf:"varint,1,opt,name=entries,proto3" json:"entries,omitempty"`
}

func (m *CountReply) Reset()                    { *m = CountReply{} }
func (m *CountReply) String() string            { return proto.CompactTextString(m) }
func (*CountReply) ProtoMessage()               {}
func (*CountReply) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{9} }

func (m *CountReply) GetEntries() int64 {
	if m != nil {
		return m.Entries
	}
	return 0
}

// Request for a stream of Entry objects in the given shard.
type ShardRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards,proto3" json:"shards,omitempty"`
}

func (m *ShardRequest) Reset()                    { *m = ShardRequest{} }
func (m *ShardRequest) String() string            { return proto.CompactTextString(m) }
func (*ShardRequest) ProtoMessage()               {}
func (*ShardRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{10} }

func (m *ShardRequest) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ShardRequest) GetShards() int64 {
	if m != nil {
		return m.Shards
	}
	return 0
}

func init() {
	proto.RegisterType((*VName)(nil), "kythe.proto.VName")
	proto.RegisterType((*VNameMask)(nil), "kythe.proto.VNameMask")
	proto.RegisterType((*Entry)(nil), "kythe.proto.Entry")
	proto.RegisterType((*Entries)(nil), "kythe.proto.Entries")
	proto.RegisterType((*ReadRequest)(nil), "kythe.proto.ReadRequest")
	proto.RegisterType((*WriteRequest)(nil), "kythe.proto.WriteRequest")
	proto.RegisterType((*WriteRequest_Update)(nil), "kythe.proto.WriteRequest.Update")
	proto.RegisterType((*WriteReply)(nil), "kythe.proto.WriteReply")
	proto.RegisterType((*ScanRequest)(nil), "kythe.proto.ScanRequest")
	proto.RegisterType((*CountRequest)(nil), "kythe.proto.CountRequest")
	proto.RegisterType((*CountReply)(nil), "kythe.proto.CountReply")
	proto.RegisterType((*ShardRequest)(nil), "kythe.proto.ShardRequest")
}
func (m *VName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if len(m.Corpus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.Corpus)))
		i += copy(dAtA[i:], m.Corpus)
	}
	if len(m.Root) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	return i, nil
}

func (m *VNameMask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VNameMask) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Signature {
		dAtA[i] = 0x8
		i++
		if m.Signature {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Corpus {
		dAtA[i] = 0x10
		i++
		if m.Corpus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Root {
		dAtA[i] = 0x18
		i++
		if m.Root {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Path {
		dAtA[i] = 0x20
		i++
		if m.Path {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Language {
		dAtA[i] = 0x28
		i++
		if m.Language {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.EdgeKind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.EdgeKind)))
		i += copy(dAtA[i:], m.EdgeKind)
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Target.Size()))
		n2, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.FactName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.FactName)))
		i += copy(dAtA[i:], m.FactName)
	}
	if len(m.FactValue) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.FactValue)))
		i += copy(dAtA[i:], m.FactValue)
	}
	return i, nil
}

func (m *Entries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStorage(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Source.Size()))
		n3, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.EdgeKind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.EdgeKind)))
		i += copy(dAtA[i:], m.EdgeKind)
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Source.Size()))
		n4, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Update) > 0 {
		for _, msg := range m.Update {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStorage(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteRequest_Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest_Update) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.EdgeKind)))
		i += copy(dAtA[i:], m.EdgeKind)
	}
	if m.Target != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Target.Size()))
		n5, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.FactName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.FactName)))
		i += copy(dAtA[i:], m.FactName)
	}
	if len(m.FactValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.FactValue)))
		i += copy(dAtA[i:], m.FactValue)
	}
	return i, nil
}

func (m *WriteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Target.Size()))
		n6, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.EdgeKind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.EdgeKind)))
		i += copy(dAtA[i:], m.EdgeKind)
	}
	if len(m.FactPrefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorage(dAtA, i, uint64(len(m.FactPrefix)))
		i += copy(dAtA[i:], m.FactPrefix)
	}
	return i, nil
}

func (m *CountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Index))
	}
	if m.Shards != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Shards))
	}
	return i, nil
}

func (m *CountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entries != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Entries))
	}
	return i, nil
}

func (m *ShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Index))
	}
	if m.Shards != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorage(dAtA, i, uint64(m.Shards))
	}
	return i, nil
}

func encodeFixed64Storage(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Storage(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStorage(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *VName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Corpus)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *VNameMask) Size() (n int) {
	var l int
	_ = l
	if m.Signature {
		n += 2
	}
	if m.Corpus {
		n += 2
	}
	if m.Root {
		n += 2
	}
	if m.Path {
		n += 2
	}
	if m.Language {
		n += 2
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactName)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactValue)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *Entries) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	if len(m.Update) > 0 {
		for _, e := range m.Update {
			l = e.Size()
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	return n
}

func (m *WriteRequest_Update) Size() (n int) {
	var l int
	_ = l
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactName)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactValue)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *WriteReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ScanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactPrefix)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *CountRequest) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStorage(uint64(m.Index))
	}
	if m.Shards != 0 {
		n += 1 + sovStorage(uint64(m.Shards))
	}
	return n
}

func (m *CountReply) Size() (n int) {
	var l int
	_ = l
	if m.Entries != 0 {
		n += 1 + sovStorage(uint64(m.Entries))
	}
	return n
}

func (m *ShardRequest) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStorage(uint64(m.Index))
	}
	if m.Shards != 0 {
		n += 1 + sovStorage(uint64(m.Shards))
	}
	return n
}

func sovStorage(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStorage(x uint64) (n int) {
	return sovStorage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VNameMask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VNameMask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VNameMask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Signature = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Corpus = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Root = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Path = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Language = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactValue = append(m.FactValue[:0], dAtA[iNdEx:postIndex]...)
			if m.FactValue == nil {
				m.FactValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, &WriteRequest_Update{})
			if err := m.Update[len(m.Update)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest_Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactValue = append(m.FactValue[:0], dAtA[iNdEx:postIndex]...)
			if m.FactValue == nil {
				m.FactValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			m.Entries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entries |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStorage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStorage
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStorage
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStorage(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStorage = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStorage   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kythe/proto/storage.proto", fileDescriptorStorage) }

var fileDescriptorStorage = []byte{
	// 511 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xd9, 0x38, 0x71, 0x9d, 0xb1, 0x4f, 0x2b, 0x84, 0x4c, 0x81, 0x34, 0xf2, 0x01, 0x21,
	0x84, 0x5c, 0x01, 0x07, 0x38, 0xf4, 0x04, 0xe2, 0x84, 0x40, 0xc8, 0x15, 0xe1, 0x58, 0x2d, 0xf6,
	0xd4, 0xb1, 0xe2, 0x78, 0xcd, 0x7a, 0x5d, 0x9a, 0x23, 0x12, 0x1c, 0xb9, 0xf3, 0x28, 0x3c, 0x02,
	0x47, 0x1e, 0x01, 0x85, 0x17, 0x41, 0xfb, 0xa7, 0xc5, 0xa5, 0x35, 0x82, 0xa8, 0x27, 0xef, 0x7c,
	0xfb, 0x79, 0xe6, 0xb7, 0x33, 0xbb, 0x70, 0x7d, 0xb1, 0x92, 0x73, 0xdc, 0xad, 0x05, 0x97, 0x7c,
	0xb7, 0x91, 0x5c, 0xb0, 0x1c, 0x63, 0x1d, 0x51, 0x5f, 0x6f, 0x99, 0x20, 0xfa, 0x40, 0x60, 0x34,
	0x7b, 0xc9, 0x96, 0x48, 0x6f, 0xc2, 0xb8, 0x29, 0xf2, 0x8a, 0xc9, 0x56, 0x60, 0x48, 0xa6, 0xe4,
	0xce, 0x38, 0xf9, 0x2d, 0xd0, 0x6b, 0xe0, 0xa6, 0x5c, 0xd4, 0x6d, 0x13, 0x0e, 0xf4, 0x96, 0x8d,
	0x28, 0x85, 0xa1, 0xe0, 0x5c, 0x86, 0x8e, 0x56, 0xf5, 0x5a, 0x69, 0x35, 0x93, 0xf3, 0x70, 0x68,
	0x34, 0xb5, 0xa6, 0xdb, 0xe0, 0x95, 0xac, 0xca, 0x5b, 0x96, 0x63, 0x38, 0xd2, 0xfa, 0x69, 0x1c,
	0x7d, 0x22, 0x30, 0xd6, 0x0c, 0x2f, 0x58, 0xb3, 0x38, 0xcf, 0xe1, 0xf5, 0x73, 0x78, 0x17, 0x72,
	0x78, 0x17, 0x70, 0x78, 0x3d, 0x1c, 0x5e, 0x87, 0xe3, 0x2b, 0x81, 0xd1, 0xb3, 0x4a, 0x8a, 0x15,
	0xbd, 0x0b, 0x6e, 0xc3, 0x5b, 0x91, 0x1a, 0x00, 0xff, 0x01, 0x8d, 0x3b, 0x3d, 0x8b, 0x35, 0x6b,
	0x62, 0x1d, 0xf4, 0x06, 0x8c, 0x31, 0xcb, 0xf1, 0x60, 0x51, 0x54, 0x99, 0x6d, 0x8e, 0xa7, 0x84,
	0xe7, 0x45, 0x95, 0xa9, 0x44, 0x92, 0x89, 0x1c, 0x0d, 0x58, 0x4f, 0x22, 0xe3, 0x50, 0x89, 0x0e,
	0x59, 0x2a, 0x0f, 0x2a, 0xb6, 0x44, 0xdb, 0x3b, 0x4f, 0x09, 0x7a, 0x3a, 0xb7, 0x00, 0xf4, 0xe6,
	0x11, 0x2b, 0x5b, 0x43, 0x1e, 0x24, 0xda, 0x3e, 0x53, 0x42, 0xf4, 0x08, 0xb6, 0x14, 0x79, 0x81,
	0x0d, 0xbd, 0x07, 0x5b, 0x68, 0x96, 0x21, 0x99, 0x3a, 0xe7, 0x6a, 0xea, 0x03, 0x26, 0x27, 0x96,
	0x68, 0x06, 0x7e, 0x82, 0x2c, 0x4b, 0xf0, 0x5d, 0x8b, 0x8d, 0xbc, 0xb4, 0x83, 0x47, 0x1f, 0x07,
	0x10, 0xbc, 0x11, 0x85, 0xc4, 0x4d, 0x32, 0x3f, 0x06, 0xb7, 0xad, 0x33, 0x26, 0x31, 0x1c, 0xe8,
	0x13, 0x4c, 0xcf, 0x78, 0xbb, 0x69, 0xe3, 0xd7, 0xda, 0x97, 0x58, 0xff, 0xf6, 0x67, 0x02, 0xae,
	0x91, 0xce, 0xe2, 0x91, 0xde, 0xb9, 0x0c, 0xfe, 0x6f, 0x2e, 0xce, 0x5f, 0xe7, 0x32, 0xfc, 0x73,
	0x2e, 0x01, 0x80, 0xc5, 0xad, 0xcb, 0x55, 0xf4, 0x1e, 0xfc, 0xfd, 0x94, 0x55, 0x9d, 0x96, 0x58,
	0x08, 0xf2, 0x2f, 0x10, 0xfd, 0xb7, 0x6c, 0x07, 0x7c, 0x0d, 0x51, 0x0b, 0x3c, 0x2c, 0x8e, 0x2d,
	0xa3, 0xe6, 0x7a, 0xa5, 0x95, 0x68, 0x0f, 0x82, 0xa7, 0xbc, 0xad, 0xe4, 0x49, 0xe5, 0xab, 0x30,
	0x2a, 0xaa, 0x0c, 0x8f, 0x75, 0x61, 0x27, 0x31, 0x81, 0x7a, 0x5b, 0xcd, 0x9c, 0x89, 0xcc, 0xbc,
	0x2d, 0x27, 0xb1, 0x51, 0x74, 0x1b, 0xc0, 0xfe, 0x5d, 0x97, 0x2b, 0x1a, 0x76, 0xef, 0x97, 0xb2,
	0x9d, 0xde, 0xa5, 0x3d, 0x08, 0xf6, 0xd5, 0x1f, 0x1b, 0x55, 0x79, 0x72, 0xff, 0xdb, 0x7a, 0x42,
	0xbe, 0xaf, 0x27, 0xe4, 0xc7, 0x7a, 0x42, 0xbe, 0xfc, 0x9c, 0x5c, 0x81, 0x9d, 0x94, 0x2f, 0xe3,
	0x9c, 0xf3, 0xbc, 0xc4, 0x38, 0xc3, 0x23, 0xc9, 0x79, 0xd9, 0x74, 0x5b, 0xf4, 0xd6, 0xd5, 0x9f,
	0x87, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x44, 0x63, 0x39, 0x95, 0xed, 0x04, 0x00, 0x00,
}
