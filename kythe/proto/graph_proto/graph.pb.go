// Code generated by protoc-gen-gogo.
// source: kythe/proto/graph.proto
// DO NOT EDIT!

/*
	Package graph_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/graph.proto

	It has these top-level messages:
		NodesRequest
		NodesReply
		EdgesRequest
		EdgeSet
		EdgesReply
*/
package graph_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NodesRequest struct {
	// The tickets of the nodes to be looked up.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, all available facts
	// are returned for each matching node.  The filter applies to ALL requested
	// nodes.  For different filters per node, the client must issue separate
	// requests.  See EdgesRequest for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *NodesRequest) Reset()                    { *m = NodesRequest{} }
func (m *NodesRequest) String() string            { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()               {}
func (*NodesRequest) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{0} }

func (m *NodesRequest) GetTicket() []string {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *NodesRequest) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

type NodesReply struct {
	// One NodeInfo, keyed by its ticket, is returned for each requested node
	// that had a non-zero number of matching facts.  Each NodeInfo will not have
	// its ticket set since it would just be a copy of the map keys.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodesReply) Reset()                    { *m = NodesReply{} }
func (m *NodesReply) String() string            { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()               {}
func (*NodesReply) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{1} }

func (m *NodesReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type EdgesRequest struct {
	// The tickets of the source nodes for which edges are requested.
	// The service will return an error if no tickets are specified.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// The kinds of outbound edges that should be returned for each matching
	// source node.  If empty, all available edge kinds are returned.
	Kind []string `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for the target node of each matching edge.  If filter is empty,
	// no facts are returned.
	//
	// The supported glob operators are:
	//   *   zero or more non-slash characters ([^/]*)
	//   ?   any single non-slash character ([^/])
	//   **  zero or more of any character (.*)
	//
	// All other characters match literally, and the glob must consume the entire
	// name in order to match.  The facts returned are the union of those matched
	// by all the globs provided.
	Filter []string `protobuf:"bytes,3,rep,name=filter" json:"filter,omitempty"`
	// The edges matching a request are organized into logical pages.  The size
	// of each page is a number of distinct edges.  Notionally: All the matching
	// edges are ordered lexicographically by (start_ticket, kind, end_ticket);
	// the page_token determines where in the ordering to start, and page_size
	// determines how many edges should be returned.
	//
	// If page_token is empty, edges will be returned starting at the beginning
	// of the sequence; otherwise the starting point named by the page_token will
	// be used.  Legal values of page_token are returned by the server in the
	// next_page_token field of the EdgesReply.  A page token should be treated
	// as an opaque value by the client, and is valid only relative to a
	// particular set of tickets and kinds.  If an invalid page token is
	// requested, the server will return an error.
	//
	// If page_size > 0, at most that number of edges will be returned by the
	// service for this request (see EdgeSet and EdgesReply below).
	// If page_size = 0, the default, the server will assume a reasonable default
	// page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer edges than the requested page_size,
	// even if more are available, save that it must return at least 1 edge if
	// any are available at all.
	PageSize  int32  `protobuf:"varint,8,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,9,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *EdgesRequest) Reset()                    { *m = EdgesRequest{} }
func (m *EdgesRequest) String() string            { return proto.CompactTextString(m) }
func (*EdgesRequest) ProtoMessage()               {}
func (*EdgesRequest) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{2} }

func (m *EdgesRequest) GetTicket() []string {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *EdgesRequest) GetKind() []string {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *EdgesRequest) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *EdgesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *EdgesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// An EdgeSet represents a collection of edges outbound from a single node.  The
// edges are organized into groups, each sharing a common edge kind.
//
// The number of edges represented by an EdgeSet es, denoted len(es), is the sum
// of the lengths of the repeated edge fields for all the groups in the EdgeSet.
// This count is used to determine page size in a request.
type EdgeSet struct {
	// Each group is a collection of outbound edges from source node sharing a
	// given kind, the map's keys.  In a given EdgeSet, the server will not send
	// more than one group with the same kind label.
	Groups map[string]*EdgeSet_Group `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EdgeSet) Reset()                    { *m = EdgeSet{} }
func (m *EdgeSet) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet) ProtoMessage()               {}
func (*EdgeSet) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{3} }

func (m *EdgeSet) GetGroups() map[string]*EdgeSet_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type EdgeSet_Group struct {
	Edge []*EdgeSet_Group_Edge `protobuf:"bytes,2,rep,name=edge" json:"edge,omitempty"`
}

func (m *EdgeSet_Group) Reset()                    { *m = EdgeSet_Group{} }
func (m *EdgeSet_Group) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet_Group) ProtoMessage()               {}
func (*EdgeSet_Group) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{3, 0} }

func (m *EdgeSet_Group) GetEdge() []*EdgeSet_Group_Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type EdgeSet_Group_Edge struct {
	TargetTicket string `protobuf:"bytes,1,opt,name=target_ticket,json=targetTicket,proto3" json:"target_ticket,omitempty"`
	// An optional integer to give an ordering between multiple edges of same
	// source and kind to one or more targets.  See https://kythe.io/schema
	// for when ordinals are used for a given edge kind.
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *EdgeSet_Group_Edge) Reset()                    { *m = EdgeSet_Group_Edge{} }
func (m *EdgeSet_Group_Edge) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet_Group_Edge) ProtoMessage()               {}
func (*EdgeSet_Group_Edge) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{3, 0, 0} }

func (m *EdgeSet_Group_Edge) GetTargetTicket() string {
	if m != nil {
		return m.TargetTicket
	}
	return ""
}

func (m *EdgeSet_Group_Edge) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

type EdgesReply struct {
	// This field will contain one EdgeSet for each source node with one or more
	// matching outbound edges, keyed by the source node's ticket.  The number of
	// edges represented by an EdgesReply er, denoted len(er), is the sum of
	// len(es) for each es in edge_sets.  This count is used to determine the page
	// size.
	EdgeSets map[string]*EdgeSet `protobuf:"bytes,1,rep,name=edge_sets,json=edgeSets" json:"edge_sets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// This field will contain one entry, keyed by ticket, for each distinct node
	// referenced by some edge in edgesets, for which there is one or more
	// matching facts.
	//
	// Rationale: This prevents us from having to copy the data to all the end
	// nodes, but allows the client to have that information without making
	// additional requests.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Total number of edges on all pages matching requested kinds, by kind.
	TotalEdgesByKind map[string]int64 `protobuf:"bytes,5,rep,name=total_edges_by_kind,json=totalEdgesByKind" json:"total_edges_by_kind,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// If there are additional pages of edges after the ones returned in this
	// reply, next_page_token is the page token that may be passed to fetch the
	// next page in sequence after this one.  If there are no additional edges,
	// this field will be empty.
	NextPageToken string `protobuf:"bytes,9,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *EdgesReply) Reset()                    { *m = EdgesReply{} }
func (m *EdgesReply) String() string            { return proto.CompactTextString(m) }
func (*EdgesReply) ProtoMessage()               {}
func (*EdgesReply) Descriptor() ([]byte, []int) { return fileDescriptorGraph, []int{4} }

func (m *EdgesReply) GetEdgeSets() map[string]*EdgeSet {
	if m != nil {
		return m.EdgeSets
	}
	return nil
}

func (m *EdgesReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *EdgesReply) GetTotalEdgesByKind() map[string]int64 {
	if m != nil {
		return m.TotalEdgesByKind
	}
	return nil
}

func (m *EdgesReply) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func init() {
	proto.RegisterType((*NodesRequest)(nil), "kythe.proto.NodesRequest")
	proto.RegisterType((*NodesReply)(nil), "kythe.proto.NodesReply")
	proto.RegisterType((*EdgesRequest)(nil), "kythe.proto.EdgesRequest")
	proto.RegisterType((*EdgeSet)(nil), "kythe.proto.EdgeSet")
	proto.RegisterType((*EdgeSet_Group)(nil), "kythe.proto.EdgeSet.Group")
	proto.RegisterType((*EdgeSet_Group_Edge)(nil), "kythe.proto.EdgeSet.Group.Edge")
	proto.RegisterType((*EdgesReply)(nil), "kythe.proto.EdgesReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GraphService service

type GraphServiceClient interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error)
}

type graphServiceClient struct {
	cc *grpc.ClientConn
}

func NewGraphServiceClient(cc *grpc.ClientConn) GraphServiceClient {
	return &graphServiceClient{cc}
}

func (c *graphServiceClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.GraphService/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graphServiceClient) Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error) {
	out := new(EdgesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.GraphService/Edges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GraphService service

type GraphServiceServer interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(context.Context, *NodesRequest) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(context.Context, *EdgesRequest) (*EdgesReply, error)
}

func RegisterGraphServiceServer(s *grpc.Server, srv GraphServiceServer) {
	s.RegisterService(&_GraphService_serviceDesc, srv)
}

func _GraphService_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraphServiceServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.GraphService/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraphServiceServer).Nodes(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraphService_Edges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EdgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraphServiceServer).Edges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.GraphService/Edges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraphServiceServer).Edges(ctx, req.(*EdgesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GraphService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.GraphService",
	HandlerType: (*GraphServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Nodes",
			Handler:    _GraphService_Nodes_Handler,
		},
		{
			MethodName: "Edges",
			Handler:    _GraphService_Edges_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kythe/proto/graph.proto",
}

func (m *NodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NodesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0xa
			i++
			v := m.Nodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGraph(uint64(len(k))) + msgSize
			i = encodeVarintGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGraph(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *EdgesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGraph(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGraph(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	return i, nil
}

func (m *EdgeSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for k, _ := range m.Groups {
			dAtA[i] = 0x12
			i++
			v := m.Groups[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGraph(uint64(len(k))) + msgSize
			i = encodeVarintGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGraph(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *EdgeSet_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeSet_Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Edge) > 0 {
		for _, msg := range m.Edge {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGraph(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgeSet_Group_Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeSet_Group_Edge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TargetTicket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGraph(dAtA, i, uint64(len(m.TargetTicket)))
		i += copy(dAtA[i:], m.TargetTicket)
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGraph(dAtA, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *EdgesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeSets) > 0 {
		for k, _ := range m.EdgeSets {
			dAtA[i] = 0xa
			i++
			v := m.EdgeSets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGraph(uint64(len(k))) + msgSize
			i = encodeVarintGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGraph(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x12
			i++
			v := m.Nodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGraph(uint64(len(k))) + msgSize
			i = encodeVarintGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGraph(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.TotalEdgesByKind) > 0 {
		for k, _ := range m.TotalEdgesByKind {
			dAtA[i] = 0x2a
			i++
			v := m.TotalEdgesByKind[k]
			mapSize := 1 + len(k) + sovGraph(uint64(len(k))) + 1 + sovGraph(uint64(v))
			i = encodeVarintGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintGraph(dAtA, i, uint64(v))
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGraph(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func encodeFixed64Graph(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Graph(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGraph(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	return n
}

func (m *NodesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EdgesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			l = len(s)
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	if m.PageSize != 0 {
		n += 1 + sovGraph(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovGraph(uint64(l))
	}
	return n
}

func (m *EdgeSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for k, v := range m.Groups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EdgeSet_Group) Size() (n int) {
	var l int
	_ = l
	if len(m.Edge) > 0 {
		for _, e := range m.Edge {
			l = e.Size()
			n += 1 + l + sovGraph(uint64(l))
		}
	}
	return n
}

func (m *EdgeSet_Group_Edge) Size() (n int) {
	var l int
	_ = l
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovGraph(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovGraph(uint64(m.Ordinal))
	}
	return n
}

func (m *EdgesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.EdgeSets) > 0 {
		for k, v := range m.EdgeSets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGraph(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGraph(uint64(mapEntrySize))
		}
	}
	if len(m.TotalEdgesByKind) > 0 {
		for k, v := range m.TotalEdgesByKind {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGraph(uint64(len(k))) + 1 + sovGraph(uint64(v))
			n += mapEntrySize + 1 + sovGraph(uint64(mapEntrySize))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGraph(uint64(l))
	}
	return n
}

func sovGraph(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGraph(x uint64) (n int) {
	return sovGraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &kythe_proto_common.NodeInfo{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Nodes[mapkey] = mapvalue
			} else {
				var mapvalue *kythe_proto_common.NodeInfo
				m.Nodes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = append(m.Kind, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Groups == nil {
				m.Groups = make(map[string]*EdgeSet_Group)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EdgeSet_Group{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Groups[mapkey] = mapvalue
			} else {
				var mapvalue *EdgeSet_Group
				m.Groups[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edge = append(m.Edge, &EdgeSet_Group_Edge{})
			if err := m.Edge[len(m.Edge)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet_Group_Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.EdgeSets == nil {
				m.EdgeSets = make(map[string]*EdgeSet)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EdgeSet{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.EdgeSets[mapkey] = mapvalue
			} else {
				var mapvalue *EdgeSet
				m.EdgeSets[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGraph
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &kythe_proto_common.NodeInfo{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Nodes[mapkey] = mapvalue
			} else {
				var mapvalue *kythe_proto_common.NodeInfo
				m.Nodes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEdgesByKind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.TotalEdgesByKind == nil {
				m.TotalEdgesByKind = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TotalEdgesByKind[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.TotalEdgesByKind[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGraph(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGraph
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGraph
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGraph(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGraph = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGraph   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kythe/proto/graph.proto", fileDescriptorGraph) }

var fileDescriptorGraph = []byte{
	// 612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xee, 0x3a, 0x71, 0x9b, 0x4c, 0x12, 0xfd, 0xa2, 0xfd, 0x15, 0x6a, 0x0c, 0x84, 0xc8, 0x08,
	0x14, 0x21, 0x91, 0xa2, 0xf4, 0x12, 0x21, 0xc1, 0x21, 0x28, 0xaa, 0x00, 0x09, 0x81, 0x13, 0x38,
	0x21, 0x59, 0x6e, 0x3c, 0x75, 0xad, 0xa4, 0x76, 0xb0, 0x37, 0x15, 0xee, 0x89, 0x07, 0x40, 0x70,
	0xe5, 0xc4, 0xbb, 0x70, 0xe3, 0xc8, 0x23, 0xa0, 0xf0, 0x22, 0x68, 0xff, 0x84, 0x38, 0x89, 0x23,
	0x4e, 0xdc, 0x76, 0x66, 0x67, 0xbe, 0x99, 0x6f, 0xe6, 0xdb, 0x85, 0x83, 0x71, 0xca, 0xce, 0xf0,
	0x70, 0x1a, 0x47, 0x2c, 0x3a, 0xf4, 0x63, 0x77, 0x7a, 0xd6, 0x16, 0x67, 0x5a, 0x11, 0x17, 0xd2,
	0x30, 0x8d, 0x6c, 0xd4, 0x28, 0x3a, 0x3f, 0x8f, 0x42, 0x79, 0x63, 0x3d, 0x86, 0xea, 0x8b, 0xc8,
	0xc3, 0xc4, 0xc6, 0x77, 0x33, 0x4c, 0x18, 0xbd, 0x0a, 0xbb, 0x2c, 0x18, 0x8d, 0x91, 0x19, 0xa4,
	0x59, 0x68, 0x95, 0x6d, 0x65, 0x71, 0xff, 0x69, 0x30, 0x61, 0x18, 0x1b, 0x9a, 0xf4, 0x4b, 0xcb,
	0xfa, 0x4a, 0x00, 0x14, 0xc0, 0x74, 0x92, 0xd2, 0x2e, 0xe8, 0x21, 0xb7, 0x44, 0x76, 0xa5, 0x63,
	0xb5, 0x33, 0x5d, 0xb4, 0x97, 0x71, 0xf2, 0xd8, 0x0f, 0x59, 0x9c, 0xda, 0x32, 0xc1, 0x7c, 0xa3,
	0x70, 0x84, 0x93, 0xd6, 0xa1, 0x30, 0xc6, 0xd4, 0x20, 0x4d, 0xd2, 0x2a, 0xdb, 0xfc, 0x48, 0x3b,
	0xa0, 0x5f, 0xb8, 0x93, 0x19, 0x1a, 0x5a, 0x93, 0xb4, 0x2a, 0x9d, 0x1b, 0x2b, 0xc8, 0x8a, 0x12,
	0x07, 0x78, 0x1a, 0x9e, 0x46, 0xb6, 0x0c, 0x7d, 0xa8, 0x75, 0x89, 0xf5, 0x89, 0x40, 0xb5, 0xef,
	0xf9, 0x7f, 0x67, 0x48, 0xa1, 0x38, 0x0e, 0x42, 0x4f, 0xf1, 0x13, 0xe7, 0x0c, 0xeb, 0x42, 0x96,
	0x35, 0xbd, 0x0e, 0xe5, 0xa9, 0xeb, 0xa3, 0x93, 0x04, 0x97, 0x68, 0x94, 0x9a, 0xa4, 0xa5, 0xdb,
	0x25, 0xee, 0x18, 0x04, 0x97, 0x48, 0x6f, 0x02, 0x88, 0x4b, 0x16, 0x8d, 0x31, 0x34, 0xca, 0x82,
	0x82, 0x08, 0x1f, 0x72, 0x87, 0xf5, 0x4d, 0x83, 0x3d, 0xde, 0xd0, 0x00, 0x19, 0xed, 0xc2, 0xae,
	0x1f, 0x47, 0xb3, 0x69, 0x22, 0xaa, 0x56, 0x3a, 0xcd, 0x15, 0x56, 0x2a, 0xaa, 0x7d, 0x2c, 0x42,
	0xe4, 0xb4, 0x54, 0xbc, 0xf9, 0x99, 0x80, 0x2e, 0xfc, 0xf4, 0x08, 0x8a, 0xe8, 0xf9, 0xa8, 0x10,
	0x6e, 0x6d, 0x47, 0x10, 0x96, 0x2d, 0x82, 0xcd, 0x3e, 0x14, 0xb9, 0x45, 0x6f, 0x43, 0x8d, 0xb9,
	0xb1, 0x8f, 0xcc, 0xf9, 0x33, 0x13, 0xde, 0x6e, 0x55, 0x3a, 0x87, 0x72, 0x32, 0x06, 0xec, 0x45,
	0xb1, 0x17, 0x84, 0xee, 0x44, 0x0c, 0x5f, 0xb7, 0x17, 0xe6, 0xb3, 0x62, 0x89, 0xd4, 0x35, 0x39,
	0x2b, 0xf3, 0x35, 0x54, 0x32, 0x8d, 0xe6, 0x6c, 0xf0, 0xc1, 0xea, 0x06, 0xcd, 0xed, 0x9d, 0x66,
	0xf6, 0xa7, 0x4a, 0xd4, 0x92, 0x68, 0x16, 0x8f, 0x50, 0x75, 0x69, 0x7d, 0x28, 0x02, 0xa8, 0xa5,
	0x72, 0xd5, 0xf5, 0xa0, 0xcc, 0x59, 0x39, 0x09, 0xb2, 0x85, 0xf2, 0xee, 0x6c, 0xa0, 0x2b, 0xe5,
	0xa9, 0x42, 0x6a, 0x9c, 0x25, 0x54, 0xe6, 0x52, 0xb9, 0x5a, 0x8e, 0x72, 0x33, 0xf9, 0x1b, 0xca,
	0xa5, 0x6f, 0xe1, 0x7f, 0x16, 0x31, 0x77, 0xe2, 0x70, 0xac, 0xc4, 0x39, 0x49, 0x1d, 0xa1, 0x23,
	0x5d, 0xe0, 0xdc, 0xdf, 0x86, 0x33, 0xe4, 0x29, 0xc2, 0xee, 0xa5, 0xcf, 0x83, 0xd0, 0x93, 0x90,
	0x75, 0xb6, 0xe6, 0xa6, 0x77, 0xe1, 0xbf, 0x10, 0xdf, 0x33, 0x67, 0x43, 0x52, 0x35, 0xee, 0x7e,
	0xb9, 0x90, 0x95, 0xf9, 0x0a, 0x6a, 0x2b, 0xd4, 0x72, 0x16, 0x70, 0x6f, 0x75, 0x01, 0xfb, 0x79,
	0x0b, 0xc8, 0x8c, 0xfe, 0x5f, 0x3d, 0x49, 0xf3, 0x09, 0x5c, 0xc9, 0x65, 0x9f, 0x53, 0x62, 0x3f,
	0x5b, 0xa2, 0x90, 0x01, 0xe9, 0x7c, 0x24, 0x50, 0x3d, 0xe6, 0xff, 0xdd, 0x00, 0xe3, 0x8b, 0x60,
	0x84, 0xf4, 0x11, 0xe8, 0xa2, 0x5b, 0x7a, 0x2d, 0xef, 0xd3, 0x11, 0x6f, 0xdf, 0x3c, 0xd8, 0xf2,
	0x1f, 0x59, 0x3b, 0x3c, 0x5d, 0xf4, 0xb3, 0x96, 0x9e, 0xfd, 0x3a, 0xd6, 0xd2, 0x97, 0xcb, 0xb4,
	0x76, 0x7a, 0xf5, 0xef, 0xf3, 0x06, 0xf9, 0x31, 0x6f, 0x90, 0x9f, 0xf3, 0x06, 0xf9, 0xf2, 0xab,
	0xb1, 0x73, 0xb2, 0x2b, 0xa2, 0x8e, 0x7e, 0x07, 0x00, 0x00, 0xff, 0xff, 0x93, 0xe7, 0x85, 0xdb,
	0xa2, 0x05, 0x00, 0x00,
}
