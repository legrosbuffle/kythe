// Code generated by protoc-gen-gogo.
// source: kythe/proto/analysis.proto
// DO NOT EDIT!

/*
	Package analysis_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/analysis.proto

	It has these top-level messages:
		AnalysisRequest
		AnalysisOutput
		AnalysisResult
		CompilationUnit
		FilesRequest
		FileInfo
		FileData
		CompilationBundle
*/
package analysis_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "kythe.io/third_party/proto/any_proto"
import kythe_proto "kythe.io/kythe/proto/filecontext_proto"
import kythe_proto1 "kythe.io/kythe/proto/storage_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AnalysisResult_Status int32

const (
	AnalysisResult_COMPLETE        AnalysisResult_Status = 0
	AnalysisResult_INCOMPLETE      AnalysisResult_Status = 1
	AnalysisResult_INVALID_REQUEST AnalysisResult_Status = 2
)

var AnalysisResult_Status_name = map[int32]string{
	0: "COMPLETE",
	1: "INCOMPLETE",
	2: "INVALID_REQUEST",
}
var AnalysisResult_Status_value = map[string]int32{
	"COMPLETE":        0,
	"INCOMPLETE":      1,
	"INVALID_REQUEST": 2,
}

func (x AnalysisResult_Status) String() string {
	return proto.EnumName(AnalysisResult_Status_name, int32(x))
}
func (AnalysisResult_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAnalysis, []int{2, 0}
}

// An AnalysisRequest instructs an analyzer to perform an analysis on a single
// CompilationUnit.
type AnalysisRequest struct {
	// The compilation to analyze.
	Compilation *CompilationUnit `protobuf:"bytes,1,opt,name=compilation" json:"compilation,omitempty"`
	// The address of a file data service to use.  If this is provided, it should
	// be used in preference to any other file data service the analyzer may know
	// about for this compilation.
	FileDataService string `protobuf:"bytes,2,opt,name=file_data_service,json=fileDataService,proto3" json:"file_data_service,omitempty"`
	// The revision marker that should be attributed to this compilation.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *AnalysisRequest) Reset()                    { *m = AnalysisRequest{} }
func (m *AnalysisRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalysisRequest) ProtoMessage()               {}
func (*AnalysisRequest) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{0} }

func (m *AnalysisRequest) GetCompilation() *CompilationUnit {
	if m != nil {
		return m.Compilation
	}
	return nil
}

func (m *AnalysisRequest) GetFileDataService() string {
	if m != nil {
		return m.FileDataService
	}
	return ""
}

func (m *AnalysisRequest) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

// AnalysisOutput contains an output artifact for the current analysis taking
// place.  A given analysis may not produce any outputs.  It is okay for an
// indexer to send an empty AnalysisOutput message if needed to keep the RPC
// channel alive; the driver must correctly handle this.
//
// The format of value is determined by the analyzer. Kythe language indexers
// emit wire-format kythe.proto.Entry messages.
type AnalysisOutput struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// An analyzer may optionally report the final result of analysis by
	// populating this field in the last output it emits.
	//
	// Constraints: If final_result is set, value must be unset, and once a
	// final_result has been sent no further outputs may be sent. The driver must
	// enforce these constraints by aborting and discarding the request if the
	// analyzer sends additional data after the final_result. It is legal for the
	// analyzer to omit any final_result, in which case the driver will assume
	// that the analysis was completed successfully.
	FinalResult *AnalysisResult `protobuf:"bytes,10,opt,name=final_result,json=finalResult" json:"final_result,omitempty"`
}

func (m *AnalysisOutput) Reset()                    { *m = AnalysisOutput{} }
func (m *AnalysisOutput) String() string            { return proto.CompactTextString(m) }
func (*AnalysisOutput) ProtoMessage()               {}
func (*AnalysisOutput) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{1} }

func (m *AnalysisOutput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AnalysisOutput) GetFinalResult() *AnalysisResult {
	if m != nil {
		return m.FinalResult
	}
	return nil
}

// AnalysisResult documents the analyzer's opinion of an analysis request.
type AnalysisResult struct {
	Status  AnalysisResult_Status `protobuf:"varint,1,opt,name=status,proto3,enum=kythe.proto.AnalysisResult_Status" json:"status,omitempty"`
	Summary string                `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *AnalysisResult) Reset()                    { *m = AnalysisResult{} }
func (m *AnalysisResult) String() string            { return proto.CompactTextString(m) }
func (*AnalysisResult) ProtoMessage()               {}
func (*AnalysisResult) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{2} }

func (m *AnalysisResult) GetStatus() AnalysisResult_Status {
	if m != nil {
		return m.Status
	}
	return AnalysisResult_COMPLETE
}

func (m *AnalysisResult) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

// Describes a single unit of compilation.
type CompilationUnit struct {
	// The base VName for the compilation and any generated VNames from its
	// analysis. Generally, the `language` component designates the language of
	// the compilation's sources.
	VName *kythe_proto1.VName `protobuf:"bytes,1,opt,name=v_name,json=vName" json:"v_name,omitempty"`
	// All files that might be touched in the course of this compilation.
	// Consumers of the CompilationUnit may not assume anything about the order
	// of the elements of this field.
	RequiredInput []*CompilationUnit_FileInput `protobuf:"bytes,3,rep,name=required_input,json=requiredInput" json:"required_input,omitempty"`
	// Set by the extractor to indicate that the original input had compile
	// errors. This is used to check validity of the sharded analysis.
	HasCompileErrors bool `protobuf:"varint,4,opt,name=has_compile_errors,json=hasCompileErrors,proto3" json:"has_compile_errors,omitempty"`
	// The arguments to pass to a compiler tool for this compilation unit,
	// including the compiler executable, flags, and input files.
	Argument []string `protobuf:"bytes,5,rep,name=argument" json:"argument,omitempty"`
	// Of those files in `required_input`, the ones that this CompilationUnit
	// is intended to analyze. This is necessary to support languages like Go,
	// where a single translation unit may contain many source files that must all
	// be processed at once (while excluding source files that belong to other
	// CUs/packages, if any).
	SourceFile []string `protobuf:"bytes,6,rep,name=source_file,json=sourceFile" json:"source_file,omitempty"`
	// The output key of the CompilationUnit; for example, the object file that
	// it writes.  The output key for a compilation should match the path in the
	// FileInfo message of a dependent compilation that consumes its output.
	OutputKey string `protobuf:"bytes,7,opt,name=output_key,json=outputKey,proto3" json:"output_key,omitempty"`
	// The absolute path of the current working directory where the build tool
	// was invoked.  During analysis, a file whose path has working_directory
	// plus a path separator as an exact prefix is considered accessible from
	// that same path without said prefix.  It is only necessary to set this
	// field if the build tool requires it.
	WorkingDirectory string `protobuf:"bytes,8,opt,name=working_directory,json=workingDirectory,proto3" json:"working_directory,omitempty"`
	// For languages that make use of resource contexts (like C++), the context
	// that should be initially entered.
	// TODO(zarko): What is a "resource context"? Needs a clear definition and/or
	// a link to one.
	EntryContext string `protobuf:"bytes,9,opt,name=entry_context,json=entryContext,proto3" json:"entry_context,omitempty"`
	// A collection of environment variables that the build environment expects
	// to be set.  As a rule, we only record variables here that must be set to
	// specific values for the build to work.  Users of this field may not assume
	// anything about the order of values; in particular the pipeline is free to
	// sort by name in order to canonicalize the message.
	Environment []*CompilationUnit_Env `protobuf:"bytes,10,rep,name=environment" json:"environment,omitempty"`
	// Per-language or per-tool details.
	Details []*google_protobuf.Any `protobuf:"bytes,11,rep,name=details" json:"details,omitempty"`
}

func (m *CompilationUnit) Reset()                    { *m = CompilationUnit{} }
func (m *CompilationUnit) String() string            { return proto.CompactTextString(m) }
func (*CompilationUnit) ProtoMessage()               {}
func (*CompilationUnit) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{3} }

func (m *CompilationUnit) GetVName() *kythe_proto1.VName {
	if m != nil {
		return m.VName
	}
	return nil
}

func (m *CompilationUnit) GetRequiredInput() []*CompilationUnit_FileInput {
	if m != nil {
		return m.RequiredInput
	}
	return nil
}

func (m *CompilationUnit) GetHasCompileErrors() bool {
	if m != nil {
		return m.HasCompileErrors
	}
	return false
}

func (m *CompilationUnit) GetArgument() []string {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *CompilationUnit) GetSourceFile() []string {
	if m != nil {
		return m.SourceFile
	}
	return nil
}

func (m *CompilationUnit) GetOutputKey() string {
	if m != nil {
		return m.OutputKey
	}
	return ""
}

func (m *CompilationUnit) GetWorkingDirectory() string {
	if m != nil {
		return m.WorkingDirectory
	}
	return ""
}

func (m *CompilationUnit) GetEntryContext() string {
	if m != nil {
		return m.EntryContext
	}
	return ""
}

func (m *CompilationUnit) GetEnvironment() []*CompilationUnit_Env {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *CompilationUnit) GetDetails() []*google_protobuf.Any {
	if m != nil {
		return m.Details
	}
	return nil
}

type CompilationUnit_FileInput struct {
	// If set, overrides the `v_name` in the `CompilationUnit` for deriving
	// VNames during analysis.
	VName *kythe_proto1.VName `protobuf:"bytes,1,opt,name=v_name,json=vName" json:"v_name,omitempty"`
	// The file's metadata. It is invalid to provide a FileInput without both
	// the file's path and digest.
	Info *FileInfo `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// The file's context-dependent version table.
	Context *kythe_proto.ContextDependentVersion `protobuf:"bytes,3,opt,name=context" json:"context,omitempty"`
}

func (m *CompilationUnit_FileInput) Reset()         { *m = CompilationUnit_FileInput{} }
func (m *CompilationUnit_FileInput) String() string { return proto.CompactTextString(m) }
func (*CompilationUnit_FileInput) ProtoMessage()    {}
func (*CompilationUnit_FileInput) Descriptor() ([]byte, []int) {
	return fileDescriptorAnalysis, []int{3, 0}
}

func (m *CompilationUnit_FileInput) GetVName() *kythe_proto1.VName {
	if m != nil {
		return m.VName
	}
	return nil
}

func (m *CompilationUnit_FileInput) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CompilationUnit_FileInput) GetContext() *kythe_proto.ContextDependentVersion {
	if m != nil {
		return m.Context
	}
	return nil
}

// An Env message represents the name and value of a single environment
// variable in the build environment.
type CompilationUnit_Env struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *CompilationUnit_Env) Reset()                    { *m = CompilationUnit_Env{} }
func (m *CompilationUnit_Env) String() string            { return proto.CompactTextString(m) }
func (*CompilationUnit_Env) ProtoMessage()               {}
func (*CompilationUnit_Env) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{3, 1} }

func (m *CompilationUnit_Env) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CompilationUnit_Env) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A FilesRequest specifies a collection of files to be fetched from a
// FileDataService.
type FilesRequest struct {
	Files []*FileInfo `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
}

func (m *FilesRequest) Reset()                    { *m = FilesRequest{} }
func (m *FilesRequest) String() string            { return proto.CompactTextString(m) }
func (*FilesRequest) ProtoMessage()               {}
func (*FilesRequest) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{4} }

func (m *FilesRequest) GetFiles() []*FileInfo {
	if m != nil {
		return m.Files
	}
	return nil
}

// A FileInfo identifies a file used for analysis.
// At least one of the path and digest fields must be non-empty.
type FileInfo struct {
	// The path of the file relative to the working directory of the compilation
	// command, which is typically the root of the build.
	// For example:
	//  file/base/file.cc
	//  ../../base/atomic_ref_count.h
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The lowercase ascii hex SHA-256 digest of the file contents.
	Digest string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{5} }

func (m *FileInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileInfo) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

// A FileData carries the content of a single file, as returned from the Get
// method of a FileDataService.
type FileData struct {
	// The content of the file, if known.  If missing == true, this field must be
	// empty.
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// A (possibly normalized) copy of the non-empty fields of the FileInfo
	// message from the Get request.  If either field from the original request
	// was empty, the server may optionally fill in that field in the reply if it
	// is known.  For example, if the client requested a file by path only and
	// the server found it, the reply MAY fill in the digest.
	Info *FileInfo `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// If true, no data are available for the requested file, and the content
	// field must be empty.  If false, the content field contains the complete
	// file content (which may be empty).
	Missing bool `protobuf:"varint,3,opt,name=missing,proto3" json:"missing,omitempty"`
}

func (m *FileData) Reset()                    { *m = FileData{} }
func (m *FileData) String() string            { return proto.CompactTextString(m) }
func (*FileData) ProtoMessage()               {}
func (*FileData) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{6} }

func (m *FileData) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *FileData) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FileData) GetMissing() bool {
	if m != nil {
		return m.Missing
	}
	return false
}

// A CompilationBundle carries a CompilationUnit and its required FileData.
type CompilationBundle struct {
	// The CompilationUnit to be analyzed.
	Unit *CompilationUnit `protobuf:"bytes,1,opt,name=unit" json:"unit,omitempty"`
	// File data for the CompilationUnit's required_input.
	Files []*FileData `protobuf:"bytes,2,rep,name=files" json:"files,omitempty"`
}

func (m *CompilationBundle) Reset()                    { *m = CompilationBundle{} }
func (m *CompilationBundle) String() string            { return proto.CompactTextString(m) }
func (*CompilationBundle) ProtoMessage()               {}
func (*CompilationBundle) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{7} }

func (m *CompilationBundle) GetUnit() *CompilationUnit {
	if m != nil {
		return m.Unit
	}
	return nil
}

func (m *CompilationBundle) GetFiles() []*FileData {
	if m != nil {
		return m.Files
	}
	return nil
}

func init() {
	proto.RegisterType((*AnalysisRequest)(nil), "kythe.proto.AnalysisRequest")
	proto.RegisterType((*AnalysisOutput)(nil), "kythe.proto.AnalysisOutput")
	proto.RegisterType((*AnalysisResult)(nil), "kythe.proto.AnalysisResult")
	proto.RegisterType((*CompilationUnit)(nil), "kythe.proto.CompilationUnit")
	proto.RegisterType((*CompilationUnit_FileInput)(nil), "kythe.proto.CompilationUnit.FileInput")
	proto.RegisterType((*CompilationUnit_Env)(nil), "kythe.proto.CompilationUnit.Env")
	proto.RegisterType((*FilesRequest)(nil), "kythe.proto.FilesRequest")
	proto.RegisterType((*FileInfo)(nil), "kythe.proto.FileInfo")
	proto.RegisterType((*FileData)(nil), "kythe.proto.FileData")
	proto.RegisterType((*CompilationBundle)(nil), "kythe.proto.CompilationBundle")
	proto.RegisterEnum("kythe.proto.AnalysisResult_Status", AnalysisResult_Status_name, AnalysisResult_Status_value)
}
func (m *AnalysisRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Compilation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Compilation.Size()))
		n1, err := m.Compilation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.FileDataService) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.FileDataService)))
		i += copy(dAtA[i:], m.FileDataService)
	}
	if len(m.Revision) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Revision)))
		i += copy(dAtA[i:], m.Revision)
	}
	return i, nil
}

func (m *AnalysisOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.FinalResult != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.FinalResult.Size()))
		n2, err := m.FinalResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *AnalysisResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Status))
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	return i, nil
}

func (m *CompilationUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompilationUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.VName.Size()))
		n3, err := m.VName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.RequiredInput) > 0 {
		for _, msg := range m.RequiredInput {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAnalysis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HasCompileErrors {
		dAtA[i] = 0x20
		i++
		if m.HasCompileErrors {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SourceFile) > 0 {
		for _, s := range m.SourceFile {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.OutputKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.OutputKey)))
		i += copy(dAtA[i:], m.OutputKey)
	}
	if len(m.WorkingDirectory) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.WorkingDirectory)))
		i += copy(dAtA[i:], m.WorkingDirectory)
	}
	if len(m.EntryContext) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.EntryContext)))
		i += copy(dAtA[i:], m.EntryContext)
	}
	if len(m.Environment) > 0 {
		for _, msg := range m.Environment {
			dAtA[i] = 0x52
			i++
			i = encodeVarintAnalysis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Details) > 0 {
		for _, msg := range m.Details {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintAnalysis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CompilationUnit_FileInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompilationUnit_FileInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.VName.Size()))
		n4, err := m.VName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Info.Size()))
		n5, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Context != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Context.Size()))
		n6, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CompilationUnit_Env) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompilationUnit_Env) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *FilesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalysis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	return i, nil
}

func (m *FileData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Info.Size()))
		n7, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Missing {
		dAtA[i] = 0x18
		i++
		if m.Missing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CompilationBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompilationBundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Unit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalysis(dAtA, i, uint64(m.Unit.Size()))
		n8, err := m.Unit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAnalysis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Analysis(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Analysis(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAnalysis(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AnalysisRequest) Size() (n int) {
	var l int
	_ = l
	if m.Compilation != nil {
		l = m.Compilation.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.FileDataService)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *AnalysisOutput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.FinalResult != nil {
		l = m.FinalResult.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *AnalysisResult) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAnalysis(uint64(m.Status))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *CompilationUnit) Size() (n int) {
	var l int
	_ = l
	if m.VName != nil {
		l = m.VName.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.RequiredInput) > 0 {
		for _, e := range m.RequiredInput {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if m.HasCompileErrors {
		n += 2
	}
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			l = len(s)
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if len(m.SourceFile) > 0 {
		for _, s := range m.SourceFile {
			l = len(s)
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	l = len(m.OutputKey)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.WorkingDirectory)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.EntryContext)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.Environment) > 0 {
		for _, e := range m.Environment {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func (m *CompilationUnit_FileInput) Size() (n int) {
	var l int
	_ = l
	if m.VName != nil {
		l = m.VName.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *CompilationUnit_Env) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *FilesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *FileData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Missing {
		n += 2
	}
	return n
}

func (m *CompilationBundle) Size() (n int) {
	var l int
	_ = l
	if m.Unit != nil {
		l = m.Unit.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func sovAnalysis(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAnalysis(x uint64) (n int) {
	return sovAnalysis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnalysisRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compilation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compilation == nil {
				m.Compilation = &CompilationUnit{}
			}
			if err := m.Compilation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDataService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDataService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalResult == nil {
				m.FinalResult = &AnalysisResult{}
			}
			if err := m.FinalResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (AnalysisResult_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompilationUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompilationUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VName == nil {
				m.VName = &kythe_proto1.VName{}
			}
			if err := m.VName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredInput = append(m.RequiredInput, &CompilationUnit_FileInput{})
			if err := m.RequiredInput[len(m.RequiredInput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCompileErrors", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCompileErrors = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = append(m.Argument, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceFile = append(m.SourceFile, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = append(m.Environment, &CompilationUnit_Env{})
			if err := m.Environment[len(m.Environment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &google_protobuf.Any{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_FileInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VName == nil {
				m.VName = &kythe_proto1.VName{}
			}
			if err := m.VName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &FileInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kythe_proto.ContextDependentVersion{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_Env) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Env: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Env: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &FileInfo{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &FileInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Missing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Missing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompilationBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompilationBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unit == nil {
				m.Unit = &CompilationUnit{}
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &FileData{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAnalysis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAnalysis
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAnalysis
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAnalysis(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAnalysis = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAnalysis   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kythe/proto/analysis.proto", fileDescriptorAnalysis) }

var fileDescriptorAnalysis = []byte{
	// 815 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x5f, 0x6f, 0xdc, 0x44,
	0x10, 0xaf, 0x73, 0xff, 0xc7, 0xd7, 0xe4, 0xb2, 0x14, 0x64, 0x0e, 0x9a, 0x9e, 0x0c, 0x42, 0x29,
	0x45, 0x0e, 0x0a, 0x88, 0x07, 0x2a, 0x45, 0xca, 0x9f, 0x43, 0x0a, 0xb4, 0x29, 0x38, 0x6d, 0x5e,
	0xad, 0xed, 0xdd, 0xdc, 0x65, 0x15, 0x7b, 0xf7, 0xba, 0xbb, 0x36, 0xf8, 0x9b, 0xc0, 0x23, 0xe2,
	0x3b, 0xf0, 0x19, 0x78, 0xe4, 0x23, 0xa0, 0xf0, 0x25, 0x78, 0x44, 0xbb, 0x6b, 0xdf, 0x5d, 0x2a,
	0x35, 0x6a, 0x9f, 0xec, 0xdf, 0xcc, 0x6f, 0x76, 0x7e, 0x33, 0xb3, 0xb3, 0x30, 0xbc, 0x2a, 0xf5,
	0x25, 0xee, 0x2d, 0xa4, 0xd0, 0x62, 0x8f, 0x72, 0x9a, 0x96, 0x8a, 0xa9, 0xc8, 0x42, 0xe2, 0x5b,
	0x9f, 0x03, 0xc3, 0x0f, 0xe7, 0x42, 0xcc, 0xd3, 0x8a, 0xf9, 0x32, 0x9f, 0xed, 0x51, 0x5e, 0x56,
	0xae, 0xfb, 0xeb, 0x67, 0xcc, 0x58, 0x8a, 0x13, 0xc1, 0x35, 0xfe, 0xa2, 0xeb, 0xc8, 0x75, 0xb7,
	0xd2, 0x42, 0xd2, 0x79, 0x75, 0x68, 0xf8, 0x9b, 0x07, 0x5b, 0x87, 0x55, 0xd2, 0x18, 0x5f, 0xe5,
	0xa8, 0x34, 0x39, 0x00, 0x7f, 0x22, 0xb2, 0x05, 0x4b, 0xa9, 0x66, 0x82, 0x07, 0xde, 0xc8, 0xdb,
	0xf5, 0xf7, 0x3f, 0x8e, 0xd6, 0xb4, 0x44, 0xc7, 0x2b, 0xff, 0x0b, 0xce, 0x74, 0xbc, 0x1e, 0x40,
	0x3e, 0x87, 0x6d, 0xa3, 0x21, 0x99, 0x52, 0x4d, 0x13, 0x85, 0xb2, 0x60, 0x13, 0x0c, 0x36, 0x46,
	0xde, 0x6e, 0x2f, 0xde, 0x32, 0x8e, 0x13, 0xaa, 0xe9, 0xb9, 0x33, 0x93, 0x21, 0x74, 0x25, 0x16,
	0x4c, 0x99, 0x44, 0x0d, 0x4b, 0x59, 0xe2, 0x70, 0x06, 0x9b, 0xb5, 0xb4, 0x67, 0xb9, 0x5e, 0xe4,
	0x9a, 0xdc, 0x83, 0x56, 0x41, 0xd3, 0x1c, 0xad, 0xa6, 0x7e, 0xec, 0x00, 0x39, 0x80, 0xfe, 0x8c,
	0x71, 0x9a, 0x26, 0x12, 0x55, 0x9e, 0xea, 0x00, 0xac, 0xe0, 0x8f, 0x6e, 0x08, 0x5e, 0xd5, 0x68,
	0x28, 0xb1, 0x6f, 0x03, 0x1c, 0x08, 0xff, 0xf0, 0x56, 0x89, 0x9c, 0x89, 0x7c, 0x0b, 0x6d, 0xa5,
	0xa9, 0xce, 0x95, 0xcd, 0xb4, 0xb9, 0x1f, 0xde, 0x72, 0x58, 0x74, 0x6e, 0x99, 0x71, 0x15, 0x41,
	0x02, 0xe8, 0xa8, 0x3c, 0xcb, 0xa8, 0x2c, 0xab, 0xa2, 0x6b, 0x18, 0x3e, 0x86, 0xb6, 0xe3, 0x92,
	0x3e, 0x74, 0x8f, 0x9f, 0x3d, 0xfd, 0xf1, 0xc9, 0xf8, 0xf9, 0x78, 0x70, 0x87, 0x6c, 0x02, 0x9c,
	0x9e, 0x2d, 0xb1, 0x47, 0xde, 0x83, 0xad, 0xd3, 0xb3, 0x8b, 0xc3, 0x27, 0xa7, 0x27, 0x49, 0x3c,
	0xfe, 0xe9, 0xc5, 0xf8, 0xfc, 0xf9, 0x60, 0x23, 0xfc, 0xb3, 0x05, 0x5b, 0xaf, 0xb5, 0x9d, 0x3c,
	0x84, 0x76, 0x91, 0x70, 0x9a, 0x61, 0x35, 0x24, 0x72, 0x43, 0xe6, 0xc5, 0x19, 0xcd, 0x30, 0x6e,
	0x15, 0xe6, 0x43, 0x9e, 0xc2, 0xa6, 0xc4, 0x57, 0x39, 0x93, 0x38, 0x4d, 0x18, 0x5f, 0xe4, 0x3a,
	0x68, 0x8c, 0x1a, 0xbb, 0xfe, 0xfe, 0x67, 0xb7, 0xcd, 0x35, 0xfa, 0x8e, 0xa5, 0x78, 0x6a, 0xd8,
	0xf1, 0xdd, 0x3a, 0xda, 0x42, 0xf2, 0x05, 0x90, 0x4b, 0xaa, 0x12, 0x37, 0x76, 0x4c, 0x50, 0x4a,
	0x21, 0x55, 0xd0, 0x1c, 0x79, 0xbb, 0xdd, 0x78, 0x70, 0x49, 0x95, 0x3b, 0x08, 0xc7, 0xd6, 0x6e,
	0xa6, 0x4c, 0xe5, 0x3c, 0xcf, 0x90, 0xeb, 0xa0, 0x35, 0x6a, 0x98, 0x29, 0xd7, 0x98, 0x3c, 0x00,
	0x5f, 0x89, 0x5c, 0x4e, 0x30, 0x31, 0x77, 0x23, 0x68, 0x5b, 0x37, 0x38, 0x93, 0x49, 0x4f, 0xee,
	0x03, 0x08, 0x3b, 0xfe, 0xe4, 0x0a, 0xcb, 0xa0, 0x63, 0x5b, 0xda, 0x73, 0x96, 0x1f, 0xb0, 0x24,
	0x8f, 0x60, 0xfb, 0x67, 0x21, 0xaf, 0x18, 0x9f, 0x27, 0x53, 0x26, 0x71, 0xa2, 0x85, 0x2c, 0x83,
	0xae, 0x65, 0x0d, 0x2a, 0xc7, 0x49, 0x6d, 0x27, 0x9f, 0xc0, 0x5d, 0xe4, 0x5a, 0x96, 0x49, 0xb5,
	0x20, 0x41, 0xcf, 0x12, 0xfb, 0xd6, 0x78, 0xec, 0x6c, 0xe4, 0x08, 0x7c, 0xe4, 0x05, 0x93, 0x82,
	0x5b, 0xc1, 0x60, 0xfb, 0x34, 0xba, 0xb5, 0x4f, 0x63, 0x5e, 0xc4, 0xeb, 0x41, 0x24, 0x82, 0xce,
	0x14, 0x35, 0x65, 0xa9, 0x0a, 0x7c, 0x1b, 0x7f, 0x2f, 0x72, 0xeb, 0x1b, 0xd5, 0xeb, 0x1b, 0x1d,
	0xf2, 0x32, 0xae, 0x49, 0xc3, 0xdf, 0x3d, 0xe8, 0x2d, 0x9b, 0xfd, 0x2e, 0x73, 0x7d, 0x08, 0x4d,
	0xc6, 0x67, 0xc2, 0x5e, 0x35, 0x7f, 0xff, 0xfd, 0x1b, 0x44, 0x77, 0xe0, 0x4c, 0xc4, 0x96, 0x42,
	0x0e, 0xa0, 0x53, 0x97, 0xdd, 0xb0, 0xec, 0x4f, 0x5f, 0xab, 0xc9, 0xfa, 0x4e, 0x70, 0x81, 0x7c,
	0x8a, 0x5c, 0x5f, 0xa0, 0x34, 0x6b, 0x18, 0xd7, 0x41, 0xc3, 0x3d, 0x68, 0x8c, 0x79, 0x41, 0x08,
	0x34, 0x97, 0xd2, 0x7a, 0xb1, 0xfd, 0x5f, 0x2d, 0xa6, 0xbb, 0xf1, 0x0e, 0x7c, 0xdf, 0xec, 0x6e,
	0x0c, 0x1a, 0xe1, 0x63, 0xe8, 0x1b, 0x21, 0xcb, 0xe7, 0xe5, 0x11, 0xb4, 0xcc, 0xa4, 0xcd, 0x6a,
	0x35, 0xde, 0x2c, 0xd9, 0x71, 0xc2, 0x6f, 0xa0, 0x5b, 0x9b, 0x4c, 0xe2, 0x05, 0xd5, 0x97, 0x75,
	0x62, 0xf3, 0x4f, 0x3e, 0x80, 0xf6, 0x94, 0xcd, 0x51, 0xe9, 0x2a, 0x73, 0x85, 0x42, 0xe6, 0xe2,
	0xcc, 0x53, 0x63, 0x16, 0xd2, 0x96, 0xc0, 0x75, 0xf5, 0x6e, 0xd4, 0xf0, 0x5d, 0x9a, 0x17, 0x40,
	0x27, 0x63, 0x4a, 0x31, 0x3e, 0xb7, 0xcd, 0xeb, 0xc6, 0x35, 0x0c, 0x25, 0x6c, 0xaf, 0x5d, 0x87,
	0xa3, 0x9c, 0x4f, 0x53, 0x24, 0x5f, 0x42, 0x33, 0xe7, 0x4c, 0xbf, 0xd5, 0xe3, 0x69, 0x99, 0xab,
	0xb6, 0x6c, 0xbc, 0xa1, 0x2d, 0xa6, 0x96, 0xaa, 0x2d, 0x47, 0x5f, 0xff, 0x75, 0xbd, 0xe3, 0xfd,
	0x7d, 0xbd, 0xe3, 0xfd, 0x73, 0xbd, 0xe3, 0xfd, 0xfa, 0xef, 0xce, 0x1d, 0x78, 0x30, 0x11, 0x59,
	0x7d, 0xc5, 0xa6, 0x58, 0x68, 0x21, 0x52, 0xb5, 0x7e, 0xc4, 0x7f, 0x9e, 0xf7, 0xb2, 0x6d, 0xff,
	0xbe, 0xfa, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x88, 0x1e, 0x62, 0xa4, 0x73, 0x06, 0x00, 0x00,
}
